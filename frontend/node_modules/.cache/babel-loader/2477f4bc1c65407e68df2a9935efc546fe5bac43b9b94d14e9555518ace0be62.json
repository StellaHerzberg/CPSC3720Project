{"ast":null,"code":"import 'whatwg-fetch';\nconst defaultPort = \"11434\";\nconst defaultHost = `http://127.0.0.1:${defaultPort}`;\nconst version = \"0.6.0\";\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ResponseError extends Error {\n  constructor(error, status_code) {\n    super(error);\n    this.error = error;\n    this.status_code = status_code;\n    this.name = \"ResponseError\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ResponseError);\n    }\n  }\n}\nclass AbortableAsyncIterator {\n  constructor(abortController, itr, doneCallback) {\n    __publicField$1(this, \"abortController\");\n    __publicField$1(this, \"itr\");\n    __publicField$1(this, \"doneCallback\");\n    this.abortController = abortController;\n    this.itr = itr;\n    this.doneCallback = doneCallback;\n  }\n  abort() {\n    this.abortController.abort();\n  }\n  async *[Symbol.asyncIterator]() {\n    for await (const message of this.itr) {\n      if (\"error\" in message) {\n        throw new Error(message.error);\n      }\n      yield message;\n      if (message.done || message.status === \"success\") {\n        this.doneCallback();\n        return;\n      }\n    }\n    throw new Error(\"Did not receive done or success response in stream.\");\n  }\n}\nconst checkOk = async response => {\n  if (response.ok) {\n    return;\n  }\n  let message = `Error ${response.status}: ${response.statusText}`;\n  let errorData = null;\n  if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n    try {\n      errorData = await response.json();\n      message = errorData.error || message;\n    } catch (error) {\n      console.log(\"Failed to parse error response as JSON\");\n    }\n  } else {\n    try {\n      console.log(\"Getting text from response\");\n      const textResponse = await response.text();\n      message = textResponse || message;\n    } catch (error) {\n      console.log(\"Failed to get text from error response\");\n    }\n  }\n  throw new ResponseError(message, response.status);\n};\nfunction getPlatform() {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    const nav = navigator;\n    if (\"userAgentData\" in nav && nav.userAgentData?.platform) {\n      return `${nav.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n    }\n    if (navigator.platform) {\n      return `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n    }\n    return `unknown Browser/${navigator.userAgent};`;\n  } else if (typeof process !== \"undefined\") {\n    return `${process.arch} ${process.platform} Node.js/${process.version}`;\n  }\n  return \"\";\n}\nfunction normalizeHeaders(headers) {\n  if (headers instanceof Headers) {\n    const obj = {};\n    headers.forEach((value, key) => {\n      obj[key] = value;\n    });\n    return obj;\n  } else if (Array.isArray(headers)) {\n    return Object.fromEntries(headers);\n  } else {\n    return headers || {};\n  }\n}\nconst readEnvVar = (obj, key) => {\n  return obj[key];\n};\nconst fetchWithHeaders = async (fetch, url, options = {}) => {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json\",\n    \"User-Agent\": `ollama-js/${version} (${getPlatform()})`\n  };\n  options.headers = normalizeHeaders(options.headers);\n  try {\n    const parsed = new URL(url);\n    if (parsed.protocol === \"https:\" && parsed.hostname === \"ollama.com\") {\n      const apiKey = typeof process === \"object\" && process !== null && typeof process.env === \"object\" && process.env !== null ? readEnvVar(process.env, \"OLLAMA_API_KEY\") : void 0;\n      const authorization = options.headers[\"authorization\"] || options.headers[\"Authorization\"];\n      if (!authorization && apiKey) {\n        options.headers[\"Authorization\"] = `Bearer ${apiKey}`;\n      }\n    }\n  } catch (error) {\n    console.error(\"error parsing url\", error);\n  }\n  const customHeaders = Object.fromEntries(Object.entries(options.headers).filter(([key]) => !Object.keys(defaultHeaders).some(defaultKey => defaultKey.toLowerCase() === key.toLowerCase())));\n  options.headers = {\n    ...defaultHeaders,\n    ...customHeaders\n  };\n  return fetch(url, options);\n};\nconst get = async (fetch, host, options) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst post = async (fetch, host, data, options) => {\n  const isRecord = input => {\n    return input !== null && typeof input === \"object\" && !Array.isArray(input);\n  };\n  const formattedData = isRecord(data) ? JSON.stringify(data) : data;\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"POST\",\n    body: formattedData,\n    signal: options?.signal,\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst del = async (fetch, host, data, options) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"DELETE\",\n    body: JSON.stringify(data),\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst parseJSON = async function* (itr) {\n  const decoder = new TextDecoder(\"utf-8\");\n  let buffer = \"\";\n  const reader = itr.getReader();\n  while (true) {\n    const {\n      done,\n      value: chunk\n    } = await reader.read();\n    if (done) {\n      break;\n    }\n    buffer += decoder.decode(chunk);\n    const parts = buffer.split(\"\\n\");\n    buffer = parts.pop() ?? \"\";\n    for (const part of parts) {\n      try {\n        yield JSON.parse(part);\n      } catch (error) {\n        console.warn(\"invalid json: \", part);\n      }\n    }\n  }\n  for (const part of buffer.split(\"\\n\").filter(p => p !== \"\")) {\n    try {\n      yield JSON.parse(part);\n    } catch (error) {\n      console.warn(\"invalid json: \", part);\n    }\n  }\n};\nconst formatHost = host => {\n  if (!host) {\n    return defaultHost;\n  }\n  let isExplicitProtocol = host.includes(\"://\");\n  if (host.startsWith(\":\")) {\n    host = `http://127.0.0.1${host}`;\n    isExplicitProtocol = true;\n  }\n  if (!isExplicitProtocol) {\n    host = `http://${host}`;\n  }\n  const url = new URL(host);\n  let port = url.port;\n  if (!port) {\n    if (!isExplicitProtocol) {\n      port = defaultPort;\n    } else {\n      port = url.protocol === \"https:\" ? \"443\" : \"80\";\n    }\n  }\n  let auth = \"\";\n  if (url.username) {\n    auth = url.username;\n    if (url.password) {\n      auth += `:${url.password}`;\n    }\n    auth += \"@\";\n  }\n  let formattedHost = `${url.protocol}//${auth}${url.hostname}:${port}${url.pathname}`;\n  if (formattedHost.endsWith(\"/\")) {\n    formattedHost = formattedHost.slice(0, -1);\n  }\n  return formattedHost;\n};\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet Ollama$1 = class Ollama {\n  constructor(config) {\n    __publicField(this, \"config\");\n    __publicField(this, \"fetch\");\n    __publicField(this, \"ongoingStreamedRequests\", []);\n    this.config = {\n      host: \"\",\n      headers: config?.headers\n    };\n    if (!config?.proxy) {\n      this.config.host = formatHost(config?.host ?? defaultHost);\n    }\n    this.fetch = config?.fetch ?? fetch;\n  }\n  // Abort any ongoing streamed requests to Ollama\n  abort() {\n    for (const request of this.ongoingStreamedRequests) {\n      request.abort();\n    }\n    this.ongoingStreamedRequests.length = 0;\n  }\n  /**\n   * Processes a request to the Ollama server. If the request is streamable, it will return a\n   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response\n   * object.\n   * @param endpoint {string} - The endpoint to send the request to.\n   * @param request {object} - The request object to send to the endpoint.\n   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields\n   * response messages.\n   * @throws {Error} - If the response body is missing or if the response is an error.\n   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.\n   */\n  async processStreamableRequest(endpoint, request) {\n    request.stream = request.stream ?? false;\n    const host = `${this.config.host}/api/${endpoint}`;\n    if (request.stream) {\n      const abortController = new AbortController();\n      const response2 = await post(this.fetch, host, request, {\n        signal: abortController.signal,\n        headers: this.config.headers\n      });\n      if (!response2.body) {\n        throw new Error(\"Missing body\");\n      }\n      const itr = parseJSON(response2.body);\n      const abortableAsyncIterator = new AbortableAsyncIterator(abortController, itr, () => {\n        const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);\n        if (i > -1) {\n          this.ongoingStreamedRequests.splice(i, 1);\n        }\n      });\n      this.ongoingStreamedRequests.push(abortableAsyncIterator);\n      return abortableAsyncIterator;\n    }\n    const response = await post(this.fetch, host, request, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Encodes an image to base64 if it is a Uint8Array.\n   * @param image {Uint8Array | string} - The image to encode.\n   * @returns {Promise<string>} - The base64 encoded image.\n   */\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const uint8Array = new Uint8Array(image);\n      let byteString = \"\";\n      const len = uint8Array.byteLength;\n      for (let i = 0; i < len; i++) {\n        byteString += String.fromCharCode(uint8Array[i]);\n      }\n      return btoa(byteString);\n    }\n    return image;\n  }\n  /**\n   * Generates a response from a text prompt.\n   * @param request {GenerateRequest} - The request object.\n   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async generate(request) {\n    if (request.images) {\n      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));\n    }\n    return this.processStreamableRequest(\"generate\", request);\n  }\n  /**\n   * Chats with the model. The request object can contain messages with images that are either\n   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the\n   * request.\n   * @param request {ChatRequest} - The request object.\n   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an\n   * AbortableAsyncIterator that yields response messages.\n   */\n  async chat(request) {\n    if (request.messages) {\n      for (const message of request.messages) {\n        if (message.images) {\n          message.images = await Promise.all(message.images.map(this.encodeImage.bind(this)));\n        }\n      }\n    }\n    return this.processStreamableRequest(\"chat\", request);\n  }\n  /**\n   * Creates a new model from a stream of data.\n   * @param request {CreateRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.\n   */\n  async create(request) {\n    return this.processStreamableRequest(\"create\", {\n      ...request\n    });\n  }\n  /**\n   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the\n   * response should be streamed.\n   * @param request {PullRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async pull(request) {\n    return this.processStreamableRequest(\"pull\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  /**\n   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the\n   * response should be streamed.\n   * @param request {PushRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async push(request) {\n    return this.processStreamableRequest(\"push\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  /**\n   * Deletes a model from the server. The request object should contain the name of the model to\n   * delete.\n   * @param request {DeleteRequest} - The request object.\n   * @returns {Promise<StatusResponse>} - The response object.\n   */\n  async delete(request) {\n    await del(this.fetch, `${this.config.host}/api/delete`, {\n      name: request.model\n    }, {\n      headers: this.config.headers\n    });\n    return {\n      status: \"success\"\n    };\n  }\n  /**\n   * Copies a model from one name to another. The request object should contain the name of the\n   * model to copy and the new name.\n   * @param request {CopyRequest} - The request object.\n   * @returns {Promise<StatusResponse>} - The response object.\n   */\n  async copy(request) {\n    await post(this.fetch, `${this.config.host}/api/copy`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return {\n      status: \"success\"\n    };\n  }\n  /**\n   * Lists the models on the server.\n   * @returns {Promise<ListResponse>} - The response object.\n   * @throws {Error} - If the response body is missing.\n   */\n  async list() {\n    const response = await get(this.fetch, `${this.config.host}/api/tags`, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Shows the metadata of a model. The request object should contain the name of the model.\n   * @param request {ShowRequest} - The request object.\n   * @returns {Promise<ShowResponse>} - The response object.\n   */\n  async show(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/show`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Embeds text input into vectors.\n   * @param request {EmbedRequest} - The request object.\n   * @returns {Promise<EmbedResponse>} - The response object.\n   */\n  async embed(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embed`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Embeds a text prompt into a vector.\n   * @param request {EmbeddingsRequest} - The request object.\n   * @returns {Promise<EmbeddingsResponse>} - The response object.\n   */\n  async embeddings(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Lists the running models on the server\n   * @returns {Promise<ListResponse>} - The response object.\n   * @throws {Error} - If the response body is missing.\n   */\n  async ps() {\n    const response = await get(this.fetch, `${this.config.host}/api/ps`, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Performs web search using the Ollama web search API\n   * @param request {WebSearchRequest} - The search request containing query and options\n   * @returns {Promise<WebSearchResponse>} - The search results\n   * @throws {Error} - If the request is invalid or the server returns an error\n   */\n  async webSearch(request) {\n    if (!request.query || request.query.length === 0) {\n      throw new Error(\"Query is required\");\n    }\n    const response = await post(this.fetch, `https://ollama.com/api/web_search`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Fetches a single page using the Ollama web fetch API\n   * @param request {WebFetchRequest} - The fetch request containing a URL\n   * @returns {Promise<WebFetchResponse>} - The fetch result\n   * @throws {Error} - If the request is invalid or the server returns an error\n   */\n  async webFetch(request) {\n    if (!request.url || request.url.length === 0) {\n      throw new Error(\"URL is required\");\n    }\n    const response = await post(this.fetch, `https://ollama.com/api/web_fetch`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n};\nconst browser = new Ollama$1();\nexport { Ollama$1 as Ollama, browser as default };","map":{"version":3,"names":["defaultPort","defaultHost","version","__defProp$1","Object","defineProperty","__defNormalProp$1","obj","key","value","enumerable","configurable","writable","__publicField$1","ResponseError","Error","constructor","error","status_code","name","captureStackTrace","AbortableAsyncIterator","abortController","itr","doneCallback","abort","Symbol","asyncIterator","message","done","status","checkOk","response","ok","statusText","errorData","headers","get","includes","json","console","log","textResponse","text","getPlatform","window","navigator","nav","userAgentData","platform","toLowerCase","userAgent","process","arch","normalizeHeaders","Headers","forEach","Array","isArray","fromEntries","readEnvVar","fetchWithHeaders","fetch","url","options","defaultHeaders","Accept","parsed","URL","protocol","hostname","apiKey","env","authorization","customHeaders","entries","filter","keys","some","defaultKey","host","post","data","isRecord","input","formattedData","JSON","stringify","method","body","signal","del","parseJSON","decoder","TextDecoder","buffer","reader","getReader","chunk","read","decode","parts","split","pop","part","parse","warn","p","formatHost","isExplicitProtocol","startsWith","port","auth","username","password","formattedHost","pathname","endsWith","slice","__defProp","__defNormalProp","__publicField","Ollama$1","Ollama","config","proxy","request","ongoingStreamedRequests","length","processStreamableRequest","endpoint","stream","AbortController","response2","abortableAsyncIterator","i","indexOf","splice","push","encodeImage","image","uint8Array","Uint8Array","byteString","len","byteLength","String","fromCharCode","btoa","generate","images","Promise","all","map","bind","chat","messages","create","pull","model","insecure","delete","copy","list","show","embed","embeddings","ps","webSearch","query","webFetch","browser","default"],"sources":["C:/Users/epfer/Clemson/CPSC3720/Project/node_modules/ollama/dist/browser.mjs"],"sourcesContent":["import 'whatwg-fetch';\n\nconst defaultPort = \"11434\";\nconst defaultHost = `http://127.0.0.1:${defaultPort}`;\n\nconst version = \"0.6.0\";\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass ResponseError extends Error {\n  constructor(error, status_code) {\n    super(error);\n    this.error = error;\n    this.status_code = status_code;\n    this.name = \"ResponseError\";\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ResponseError);\n    }\n  }\n}\nclass AbortableAsyncIterator {\n  constructor(abortController, itr, doneCallback) {\n    __publicField$1(this, \"abortController\");\n    __publicField$1(this, \"itr\");\n    __publicField$1(this, \"doneCallback\");\n    this.abortController = abortController;\n    this.itr = itr;\n    this.doneCallback = doneCallback;\n  }\n  abort() {\n    this.abortController.abort();\n  }\n  async *[Symbol.asyncIterator]() {\n    for await (const message of this.itr) {\n      if (\"error\" in message) {\n        throw new Error(message.error);\n      }\n      yield message;\n      if (message.done || message.status === \"success\") {\n        this.doneCallback();\n        return;\n      }\n    }\n    throw new Error(\"Did not receive done or success response in stream.\");\n  }\n}\nconst checkOk = async (response) => {\n  if (response.ok) {\n    return;\n  }\n  let message = `Error ${response.status}: ${response.statusText}`;\n  let errorData = null;\n  if (response.headers.get(\"content-type\")?.includes(\"application/json\")) {\n    try {\n      errorData = await response.json();\n      message = errorData.error || message;\n    } catch (error) {\n      console.log(\"Failed to parse error response as JSON\");\n    }\n  } else {\n    try {\n      console.log(\"Getting text from response\");\n      const textResponse = await response.text();\n      message = textResponse || message;\n    } catch (error) {\n      console.log(\"Failed to get text from error response\");\n    }\n  }\n  throw new ResponseError(message, response.status);\n};\nfunction getPlatform() {\n  if (typeof window !== \"undefined\" && window.navigator) {\n    const nav = navigator;\n    if (\"userAgentData\" in nav && nav.userAgentData?.platform) {\n      return `${nav.userAgentData.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n    }\n    if (navigator.platform) {\n      return `${navigator.platform.toLowerCase()} Browser/${navigator.userAgent};`;\n    }\n    return `unknown Browser/${navigator.userAgent};`;\n  } else if (typeof process !== \"undefined\") {\n    return `${process.arch} ${process.platform} Node.js/${process.version}`;\n  }\n  return \"\";\n}\nfunction normalizeHeaders(headers) {\n  if (headers instanceof Headers) {\n    const obj = {};\n    headers.forEach((value, key) => {\n      obj[key] = value;\n    });\n    return obj;\n  } else if (Array.isArray(headers)) {\n    return Object.fromEntries(headers);\n  } else {\n    return headers || {};\n  }\n}\nconst readEnvVar = (obj, key) => {\n  return obj[key];\n};\nconst fetchWithHeaders = async (fetch, url, options = {}) => {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\",\n    Accept: \"application/json\",\n    \"User-Agent\": `ollama-js/${version} (${getPlatform()})`\n  };\n  options.headers = normalizeHeaders(options.headers);\n  try {\n    const parsed = new URL(url);\n    if (parsed.protocol === \"https:\" && parsed.hostname === \"ollama.com\") {\n      const apiKey = typeof process === \"object\" && process !== null && typeof process.env === \"object\" && process.env !== null ? readEnvVar(process.env, \"OLLAMA_API_KEY\") : void 0;\n      const authorization = options.headers[\"authorization\"] || options.headers[\"Authorization\"];\n      if (!authorization && apiKey) {\n        options.headers[\"Authorization\"] = `Bearer ${apiKey}`;\n      }\n    }\n  } catch (error) {\n    console.error(\"error parsing url\", error);\n  }\n  const customHeaders = Object.fromEntries(\n    Object.entries(options.headers).filter(\n      ([key]) => !Object.keys(defaultHeaders).some(\n        (defaultKey) => defaultKey.toLowerCase() === key.toLowerCase()\n      )\n    )\n  );\n  options.headers = {\n    ...defaultHeaders,\n    ...customHeaders\n  };\n  return fetch(url, options);\n};\nconst get = async (fetch, host, options) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst post = async (fetch, host, data, options) => {\n  const isRecord = (input) => {\n    return input !== null && typeof input === \"object\" && !Array.isArray(input);\n  };\n  const formattedData = isRecord(data) ? JSON.stringify(data) : data;\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"POST\",\n    body: formattedData,\n    signal: options?.signal,\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst del = async (fetch, host, data, options) => {\n  const response = await fetchWithHeaders(fetch, host, {\n    method: \"DELETE\",\n    body: JSON.stringify(data),\n    headers: options?.headers\n  });\n  await checkOk(response);\n  return response;\n};\nconst parseJSON = async function* (itr) {\n  const decoder = new TextDecoder(\"utf-8\");\n  let buffer = \"\";\n  const reader = itr.getReader();\n  while (true) {\n    const { done, value: chunk } = await reader.read();\n    if (done) {\n      break;\n    }\n    buffer += decoder.decode(chunk);\n    const parts = buffer.split(\"\\n\");\n    buffer = parts.pop() ?? \"\";\n    for (const part of parts) {\n      try {\n        yield JSON.parse(part);\n      } catch (error) {\n        console.warn(\"invalid json: \", part);\n      }\n    }\n  }\n  for (const part of buffer.split(\"\\n\").filter((p) => p !== \"\")) {\n    try {\n      yield JSON.parse(part);\n    } catch (error) {\n      console.warn(\"invalid json: \", part);\n    }\n  }\n};\nconst formatHost = (host) => {\n  if (!host) {\n    return defaultHost;\n  }\n  let isExplicitProtocol = host.includes(\"://\");\n  if (host.startsWith(\":\")) {\n    host = `http://127.0.0.1${host}`;\n    isExplicitProtocol = true;\n  }\n  if (!isExplicitProtocol) {\n    host = `http://${host}`;\n  }\n  const url = new URL(host);\n  let port = url.port;\n  if (!port) {\n    if (!isExplicitProtocol) {\n      port = defaultPort;\n    } else {\n      port = url.protocol === \"https:\" ? \"443\" : \"80\";\n    }\n  }\n  let auth = \"\";\n  if (url.username) {\n    auth = url.username;\n    if (url.password) {\n      auth += `:${url.password}`;\n    }\n    auth += \"@\";\n  }\n  let formattedHost = `${url.protocol}//${auth}${url.hostname}:${port}${url.pathname}`;\n  if (formattedHost.endsWith(\"/\")) {\n    formattedHost = formattedHost.slice(0, -1);\n  }\n  return formattedHost;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nlet Ollama$1 = class Ollama {\n  constructor(config) {\n    __publicField(this, \"config\");\n    __publicField(this, \"fetch\");\n    __publicField(this, \"ongoingStreamedRequests\", []);\n    this.config = {\n      host: \"\",\n      headers: config?.headers\n    };\n    if (!config?.proxy) {\n      this.config.host = formatHost(config?.host ?? defaultHost);\n    }\n    this.fetch = config?.fetch ?? fetch;\n  }\n  // Abort any ongoing streamed requests to Ollama\n  abort() {\n    for (const request of this.ongoingStreamedRequests) {\n      request.abort();\n    }\n    this.ongoingStreamedRequests.length = 0;\n  }\n  /**\n   * Processes a request to the Ollama server. If the request is streamable, it will return a\n   * AbortableAsyncIterator that yields the response messages. Otherwise, it will return the response\n   * object.\n   * @param endpoint {string} - The endpoint to send the request to.\n   * @param request {object} - The request object to send to the endpoint.\n   * @protected {T | AbortableAsyncIterator<T>} - The response object or a AbortableAsyncIterator that yields\n   * response messages.\n   * @throws {Error} - If the response body is missing or if the response is an error.\n   * @returns {Promise<T | AbortableAsyncIterator<T>>} - The response object or a AbortableAsyncIterator that yields the streamed response.\n   */\n  async processStreamableRequest(endpoint, request) {\n    request.stream = request.stream ?? false;\n    const host = `${this.config.host}/api/${endpoint}`;\n    if (request.stream) {\n      const abortController = new AbortController();\n      const response2 = await post(this.fetch, host, request, {\n        signal: abortController.signal,\n        headers: this.config.headers\n      });\n      if (!response2.body) {\n        throw new Error(\"Missing body\");\n      }\n      const itr = parseJSON(response2.body);\n      const abortableAsyncIterator = new AbortableAsyncIterator(\n        abortController,\n        itr,\n        () => {\n          const i = this.ongoingStreamedRequests.indexOf(abortableAsyncIterator);\n          if (i > -1) {\n            this.ongoingStreamedRequests.splice(i, 1);\n          }\n        }\n      );\n      this.ongoingStreamedRequests.push(abortableAsyncIterator);\n      return abortableAsyncIterator;\n    }\n    const response = await post(this.fetch, host, request, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Encodes an image to base64 if it is a Uint8Array.\n   * @param image {Uint8Array | string} - The image to encode.\n   * @returns {Promise<string>} - The base64 encoded image.\n   */\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const uint8Array = new Uint8Array(image);\n      let byteString = \"\";\n      const len = uint8Array.byteLength;\n      for (let i = 0; i < len; i++) {\n        byteString += String.fromCharCode(uint8Array[i]);\n      }\n      return btoa(byteString);\n    }\n    return image;\n  }\n  /**\n   * Generates a response from a text prompt.\n   * @param request {GenerateRequest} - The request object.\n   * @returns {Promise<GenerateResponse | AbortableAsyncIterator<GenerateResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async generate(request) {\n    if (request.images) {\n      request.images = await Promise.all(request.images.map(this.encodeImage.bind(this)));\n    }\n    return this.processStreamableRequest(\"generate\", request);\n  }\n  /**\n   * Chats with the model. The request object can contain messages with images that are either\n   * Uint8Arrays or base64 encoded strings. The images will be base64 encoded before sending the\n   * request.\n   * @param request {ChatRequest} - The request object.\n   * @returns {Promise<ChatResponse | AbortableAsyncIterator<ChatResponse>>} - The response object or an\n   * AbortableAsyncIterator that yields response messages.\n   */\n  async chat(request) {\n    if (request.messages) {\n      for (const message of request.messages) {\n        if (message.images) {\n          message.images = await Promise.all(\n            message.images.map(this.encodeImage.bind(this))\n          );\n        }\n      }\n    }\n    return this.processStreamableRequest(\"chat\", request);\n  }\n  /**\n   * Creates a new model from a stream of data.\n   * @param request {CreateRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or a stream of progress responses.\n   */\n  async create(request) {\n    return this.processStreamableRequest(\"create\", {\n      ...request\n    });\n  }\n  /**\n   * Pulls a model from the Ollama registry. The request object can contain a stream flag to indicate if the\n   * response should be streamed.\n   * @param request {PullRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async pull(request) {\n    return this.processStreamableRequest(\"pull\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  /**\n   * Pushes a model to the Ollama registry. The request object can contain a stream flag to indicate if the\n   * response should be streamed.\n   * @param request {PushRequest} - The request object.\n   * @returns {Promise<ProgressResponse | AbortableAsyncIterator<ProgressResponse>>} - The response object or\n   * an AbortableAsyncIterator that yields response messages.\n   */\n  async push(request) {\n    return this.processStreamableRequest(\"push\", {\n      name: request.model,\n      stream: request.stream,\n      insecure: request.insecure\n    });\n  }\n  /**\n   * Deletes a model from the server. The request object should contain the name of the model to\n   * delete.\n   * @param request {DeleteRequest} - The request object.\n   * @returns {Promise<StatusResponse>} - The response object.\n   */\n  async delete(request) {\n    await del(\n      this.fetch,\n      `${this.config.host}/api/delete`,\n      { name: request.model },\n      { headers: this.config.headers }\n    );\n    return { status: \"success\" };\n  }\n  /**\n   * Copies a model from one name to another. The request object should contain the name of the\n   * model to copy and the new name.\n   * @param request {CopyRequest} - The request object.\n   * @returns {Promise<StatusResponse>} - The response object.\n   */\n  async copy(request) {\n    await post(this.fetch, `${this.config.host}/api/copy`, { ...request }, {\n      headers: this.config.headers\n    });\n    return { status: \"success\" };\n  }\n  /**\n   * Lists the models on the server.\n   * @returns {Promise<ListResponse>} - The response object.\n   * @throws {Error} - If the response body is missing.\n   */\n  async list() {\n    const response = await get(this.fetch, `${this.config.host}/api/tags`, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Shows the metadata of a model. The request object should contain the name of the model.\n   * @param request {ShowRequest} - The request object.\n   * @returns {Promise<ShowResponse>} - The response object.\n   */\n  async show(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/show`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Embeds text input into vectors.\n   * @param request {EmbedRequest} - The request object.\n   * @returns {Promise<EmbedResponse>} - The response object.\n   */\n  async embed(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embed`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Embeds a text prompt into a vector.\n   * @param request {EmbeddingsRequest} - The request object.\n   * @returns {Promise<EmbeddingsResponse>} - The response object.\n   */\n  async embeddings(request) {\n    const response = await post(this.fetch, `${this.config.host}/api/embeddings`, {\n      ...request\n    }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Lists the running models on the server\n   * @returns {Promise<ListResponse>} - The response object.\n   * @throws {Error} - If the response body is missing.\n   */\n  async ps() {\n    const response = await get(this.fetch, `${this.config.host}/api/ps`, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Performs web search using the Ollama web search API\n   * @param request {WebSearchRequest} - The search request containing query and options\n   * @returns {Promise<WebSearchResponse>} - The search results\n   * @throws {Error} - If the request is invalid or the server returns an error\n   */\n  async webSearch(request) {\n    if (!request.query || request.query.length === 0) {\n      throw new Error(\"Query is required\");\n    }\n    const response = await post(this.fetch, `https://ollama.com/api/web_search`, { ...request }, {\n      headers: this.config.headers\n    });\n    return await response.json();\n  }\n  /**\n   * Fetches a single page using the Ollama web fetch API\n   * @param request {WebFetchRequest} - The fetch request containing a URL\n   * @returns {Promise<WebFetchResponse>} - The fetch result\n   * @throws {Error} - If the request is invalid or the server returns an error\n   */\n  async webFetch(request) {\n    if (!request.url || request.url.length === 0) {\n      throw new Error(\"URL is required\");\n    }\n    const response = await post(this.fetch, `https://ollama.com/api/web_fetch`, { ...request }, { headers: this.config.headers });\n    return await response.json();\n  }\n};\nconst browser = new Ollama$1();\n\nexport { Ollama$1 as Ollama, browser as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}